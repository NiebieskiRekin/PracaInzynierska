\chapter{Architektura systemu}

\section{Założenia projektowe}

Zaprojektowany system spełnia następujące wymagania funkcjonalne (TODO: scalić w spójny tekst):

\begin{itemize}
    \item Użytkownik może się uwierzytelnić na ekranie logowania.
    \item Po pomyślnym uwierzytelnieniu użytkownik jest autoryzowany do podejmowania działań na obiektach należących do wskazanej hodowli.
    \item Użytkownika ma możliwość zmiany składnika uwierzytelniającego (hasła).
    \item Po podaniu niepoprawnych danych uwierzytelniających przez użytkownika system wyświetla komunikat błędu.
    \item Użytkownik po zalogowaniu może zobaczyć wszystkie swoje konie (przypisane dla danej hodowli), 
    \item Strona pokazująca listę koni udostępnia wyszukiwarkę, za pomocą której można filtrować wyświetlanie konie.
    \item Strona z listą koni umożliwia przejście do strony z informacjami szczegółowymi danego konia.
    \item System umożliwia podejrzenie zdjęcia konia i jego powiększenie.
    \item System pozwala na dodanie wielu zdjęć do jednego konia, przełączanie się pomiędzy nimi, a także na wybór ulubionego zdjęcia.
    \item Po dodaniu pierwszego zdjęcia do konia jest ono ustalane jako ulubione.
    \item Użytkownik ma możliwość dodania, edycji oraz usunięcia koni z systemu.
    \item System pozwala na nawigację pomiędzy modułami funkcjonalności takimi jak: Konie, Weterynarze, Kowale, Wydarzenia w stajni, Asystent, Ustawienia (TODO: czy możemy to jakoś lepiej nazwać?)
    \item System umożliwia dodawanie wydarzeń dla wielu koni, czyli podkuć i zdarzeń profilaktycznych.
    \item Spośród zdarzeń profilaktycznych użytkownik ma wybór pomiędzy: dentystą, podaniem witamin, szczepieniem, odrobaczaniem.
    \item W celu dodania zdarzenia profilaktycznego użytkownik musi wybrać jego typ, uzupełnić wymagane pola, a także wybrać listę koni, do których dane zdarzenie ma zastosowanie.
    \item W miejscach, gdzie użytkownik ma do wyboru konie z listy, dostępny jest również przycisk do zaznaczenia wszystkich.
    \item Użytkownik ma możliwość dodania do tabeli weterynarza, z którym współpracuje.
    \item System podpowiada użytkownikowi weterynarzy, gdy użytkownik dodaje nowe wydarzenie wymagające podania weterynarza.
    \item Użytkownik ma możliwość dodania do tabeli kowala, z którym współpracuje.
    \item System podpowiada użytkownikowi kowali, gdy użytkownik dodaje nowe podkucie.
    \item Użytkownik może zobaczyć informacje takie jak: numer przyżyciowy, numer chipa, rocznik urodzenia, rodzaj, płeć, data przybycia do stajni, data odejścia ze stajni, a także najnowsze aktywne wydarzenia: podkucie, odrobaczanie, podanie suplementów, szczepienie, dentystę odnośnie wybranego konia na ekranie ze szczegółami. 
    \item Użytkownik może przejść z ekranu szczegółów danego konia bezpośrednio do ostatnich wydarzeń z nim związanych.
    \item Użytkownik może wygenerować raport zawierający informacje o danym koniu oraz wybrać podzbiór wydarzeń i ich zakres czasu (według daty zdarzenia).
    \item TODO: opis zdarzeń profilaktycznych, jakie pola, co wymagane, jak obliczane
    \item System wysyła powiadomienia o zbliżającym się upływie ważności podkucia lub zdarzenia profilaktycznego do użytkowników.
    \item Użytkownik ma możliwość ustawić preferencje wysyłanych powiadomień (zbiorcze dla wszystkich koni) dla każdego typu wydarzenia z osobna, z jakim wyprzedzeniem ma przyjść informacja o wygaśnięciu ważności (ile dni wyprzedzenia, o której godzinie), a także sposób transportu wiadomości (email, \st{push})
\end{itemize}


Wymagania pozafunkcjonalne:

\begin{itemize}
    \item Logowanie użytkownika odbywa się poprzez email oraz hasło.
    \item Do zmiany hasła wymagane jest podanie starego hasła oraz dwukrotne podanie nowego hasła.
    \item Treść hasła jest domyślnie maskowana na ekranie logowania, użytkownik może ją podejrzeć podczas wpisywania.
    \item przechowywanie danych autoryzacji w sposób bezpieczny, wyłącznie hashe bcrypt haseł,
    \item Lista koni jest wyświetlana jako karty ze zdjęciem (wybranym jako ulubione) i nazwą konia. W formacie przeznaczonym na większe ekrany są to 3 kolumny, natomiast na urządzeniach mobilnych jest to 1 kolumna.
    \item Po zalogowaniu wyświetlana jest lista koni.
    \item Filtrowanie koni na liście odbywa się po nazwie za pomocą wyszukania podciągu znaków frazy.
    \item Ekran pokazujący zdjęcie konia jest pokazywany po kliknięciu na zdjęcie i jest powiększany do pełnego rozmiaru karty.
    \item Dodawanie i edycja informacji dotyczących koni odbywa się poprzez dedykowany formularz walidujący podstawową poprawność pól (właściwie tylko sprawdza czy wymagane pola są uzupełnione)
    \item Operacje usunięcia wymagają potwierdzenia.
    \item Użytkownik po wybraniu widoku dodawania zdarzeń profilaktycznych ma do wyboru 5 kafelków, każdy odpowiada akcji dodania odpowiedniego zdarzenia.
    \item Użytkownik przełącza się pomiędzy wieloma zdjęciami danego konia za pomocą strzałek na ekranie szczegółów.
    \item Pod ostatnimi wydarzeniami znajduje sie panel do dodawania wydarzeń, gdzie do wybrania jest dodanie wydarzenia związanego z rozrodami/chorobami/leczeniami/zdarzeniami profilaktycznymi /podkucia
    \item Niewielki koszt i prostota administracyjna utrzymania w dłuższej perspektywie
    \item Obsługa 400 łącznych użytkowników, w tym 100 jednoczesnych sesji.
    \item Wysoki poziom bezpieczeństwa, modularnośc i izolacja komponentów systemu
    \item Intuicyjny i wygodny interfejs graficzny, działający w przeglądarce internetowej oraz jako aplikacja mobilna
\end{itemize}

% TODO: Coś czego nie mamy (aby się nie walnąć):

% \begin{itemize}
%     \item resetowanie hasła przez użytkownika, tylko admin z dostępem do bazy danych (lub ogólnie całej instancji API)
%     \item rejestracja użytkowników przez użytkownika, j.w.
%     \item rejestracja hodowli przez użytkownika, j.w.
%     \item ustawienie złożoności hasła,
%     \item integracja z zewnętrznymi systemami uwierzytelniającymi
%     \item rate limiting prób logowania, ban po zbyt wielu próbach
%     \item utrzymywanie sesji logowania, sesja trwa 15 minut i się nie odświeża (coś było implementowane, ale nie działa)
%     \item wysyłanie powiadomień push (próbowałem dodać, nie udało mi się)
% \end{itemize}

% TODO: Błędy, które nie mogą nam umknąć:
% \begin{itemize}
%     \item Sesja logowania nie utrzymuje się
%     \item Przycisk wyloguj nie działa - sesja dalej pozostaje
%     \item Można kliknąć na zdjęcie na ekranie z listą koni, aby je powiększyć zamiast przejść do szczegółów konia
%     \item Można powiększyć domyślne zdjęcie - jego brak
%     \item Na mniejszym ekranie (u mnie na laptopie 13 cali) nagłówek ma dziwne odstępy
%     \item Miejscami zdarzenia są zapisywane jako wydarzenia i na odwrót
%     \item Dodawanie zdjęć nie działa - błąd z json payload
%     \item Koń po dodaniu ma jakiś pusty wpis ze zdjęciem, przez co cały czas się kręci, ale nic nie pokazuje
%     \item Przekierowanie z / do /konie nie działa
%     \item Czerwone komunikaty błędu na ciemnozielonym gradiencie tła są słabo widoczne (mają zbyt niski kontrast)
%     \item Tworzenie raportu dla konia bez wydarzeń nie działa (przykład koń aaa)
%     \item W ustawieniach powiadomień są wciąż opcje "Oba" i "Push", które nie działają w oczekiwany sposób
%     \item Wydarzenia są pobierane WSZYSTKIE NA RAZ a następnie stronnicowane i sortowane po stronie klienta
%     \item Walidacja w wielu miejscach odbywa się tylko po stronie klienta, np. nr telefonu
%     \item Chat po dodaniu nie ma odświeżanego stanu bazy danych np. dodanie konia, dodania szczepienia dla tego konia
% \end{itemize}


\section{Opis architektury aplikacji}

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/architektura-sieciowa}
\caption{Architektura sieciowa aplikacji}\label{rys:architektura-sieciowa}
\end{figure}

Ze względu na specyfikę aplikacji umożliwiającą edycję danych dotyczących danej hodowli koni wielu użytkownikom, w szczególności korzystających w większości z urządzeń mobilnych oraz sporadycznie z komputerów osobistych, zdecydowano się na formę systemu webowego z przeglądarkowym interfejsem użytkownika. Aplikacje internetowe pozwalają na wykorzystanie bogatego i dojrzałego zaplecza technologicznego do wyświetlania stron internetowych, co znacząco upraszcza aspekt dystrybucji oprogramowania oraz współbieżnego dostępu do danych.

Dla zachowania kompatybilności z technologią progresywnych aplikacji internetowych oraz modularności zdecydowano się na rozdzielenie warstwy przetwarzania logiki biznesowej z dostępem do danych, z którą użytkownik nie wchodzi w bezpośrednią interakcję - nazywaną backend, od warstwy bezpośrednio obsługującej interfejs użytkownika i wizualną prezentację danych - frontend. Obie warstwy nie komunikują się ze sobą, lecz współdziałają w celu tworzenia pełnej funkcjonalności aplikacji. Użytkownik inicuje wszelkie interakcje z obydwoma komponentami, choć zapytania do backendu są inicjowane w przeglądarce użytkownika wchodzącego w interakcję z frontendem, a także otrzymane dane i komunikaty diagnostyczne są wyłącznie obsługiwane przez ten komponent. Komunikacja odbywa się wyłącznie na warstwie 7 modelu ISO/OSI (warstwie aplikacji) za pomocą protokołu HTTP. Frontend obługuje żądania zwracając pliki HTML, CSS i JavaScript, natomiast backend działa w bezstanowej architekturze sieciowego interfejsu programowania REST zwracającego dane w formacie serializacji JSON. 




\subsection{Frontend}

Korzystając z technologii progresywnych aplikacji internetowych (ang. Progressive Web App, PWA) oraz praktyki responsywnego projektowania stron internetowych (ang. responsive web design, RWD) zaimplementowano spójny interfejs użytkownika dla platform mobilnych. Do implementacji technologii progresywnych aplikacji internetowych wymagane jest, aby interfejs graficzny użytkownika był skomponowany w zdecydowanej większości ze statycznych dokumentów hipertekstowych HTML (HyperText Markup Language), arkuszy stylów CSS (Cascading Style Sheets) oraz kodu w języku programowania JavaScript. Statyczne pliki w podanym kontekście oznaczają podleganie nieczęstym zmianom poprzez pobranie zaktualizowanej wersji z serwera - wyłącznie między oddzielnymi wydaniami aplikacji i nigdy w celu wyświetlenia nowych danych. Interaktywna prezentacja danych jest możliwa natomiast poprzez zmianę struktury wyświetlanego dokumentu hipertekstowego wykonywaną po stronie klienta z użyciem kodu JavaScript w przeglądarce. Wymienione działanie jest wykonywane poprzez interfejs programowania Document Object Model (DOM, pl. \textit{Model Obiektowy Dokumentu}) pozwalający na częściową lub pełną modyfikację dowolnego węzła (np. paragrafu tekstu, separatora, kontrolek, obiektu multimedialnego) w hierachicznej strukturze drzewa dokumentu HTML. Interfejs ten jest w praktyce wykorzystywany przez bibliotekę React, która nieco modyfikuje model z dokumentów HTML i skryptów JavaScript na komponenty wielokrotnego użytku (zawierające wymagane fragmenty dokumentu HTML i funkcje JavaScript) budujące deklaratywne widoki (strony internetowe). Komponenty można powiązać z danymi, czyli zaprojektować ich wygląd w celu prezentacji danych zgodnie z ich schematem oraz skonfigurować ich źródło, które będzie automatycznie odświeżane dążąc do zadeklarowanego stanu. Komponenty można w sobie zagnieżdżać, odtwarzając te same aspekty hierachicznej struktury, a ich zmiany są śledzone poprzez użycie wewnętrznej dla tej biblioteki kopii Modelu Obiektowego Dokumentu nazywanego Virtual DOM (pl. Wirtualny Model Obiektowy Dokumentu).

Opisane podejście nazywa się Aplikacją jednostronicową (ang. \textit{Single-page application, SPA}), co wynika głównie ze sposobu aktualizowania interfejsu na podstawie zmian w danych poprzez kod po stronie klienta i przesyłania statycznych dokumentów HTML, pomijając jednocześnie aspekt użycia wielu stron. W przypadku prezentowanej pracy rama projektowa została dostarczona przez bibliotekę React Router, która dostarcza pakiet budujący do Aplikacji jednostronicowej, dostarczając ponadto zestaw narzędzi służących do przechodzenia pomiędzy osobnymi widokami w zależności od użytego adresu URL - nazwany router, a także moduły do efektywnego pobierania danych w tle za pomocą funkcji asynchronicznych.


\subsection{Backend}

Przetwarzanie wykonywane po stronie serwera jest realizowane w znacznej części przez komponent backendu. Został on zaimplementowany jako bezstanowy interfejs programowania REST, który obsługuje komunikację za pomocją danych serializowanych do formatu JSON. Integruje on między sobą wiele komponentów, co zostało pokazane na diagramie architektury sieciowej, Rysunek \ref{rys:architektura-sieciowa}. Jego głównym zadaniem jest udostępnienie dostępu do danych zapisanych w bazie danych przez protokół HTTP interfejsu sieciowego na warstwie 7 modelu ISO/OSI. Rola serwera HTTP jest spełniana przez framework \textit{Hono}. Framework ten pozwala na bardzo modularne tworzenie silnie typowanych endpointów, warstw pośrednich przetwarzania (\english{middleware}) i elastyczne łączenie ich w poszczególne ścieżki obsługiwane współbieżnie i wydajnie przez jeden z kilku dostępnych silników dopasowań nazywanych \english{Router}. Mimo obszernego wyboru w przypadku utworzonej aplikacji wykorzystywany jest wyłącznie najprostszy \textit{LinearRouter} ze względu na brak mierzalnych opóźnień przetwarzania wynikających z wyboru teoretycznie wolniejszego algorytmu dopasowań (pomiary były wyłącznie zależne od czasu komunikacji z bazą danych i innymi zewnętrzymi usługami) i pełną przewidywalność dopasowań, co w końcowej fazie projektu okazało się być problemem ze względu na złożoność ścieżek dopasowań. Ze względu na wymóg współbieżnego, spójnego dostępu do danych o złożonych, ale stabilnych relacjach została wybrana relacyjna baza danych \textit{PostgreSQL}. Spośród dostępnych na rynku rozwiązań wyróżnia się ona brakiem opłat licencyjnych, bogatą dokumentacją, bardzo dobrą optymalizacją przetwarzania na małych i średnich zbiorach danych, obszernym zestawem funkcji, a także jest dobrze znana i lubiana przez zespół projektowy. Zapytania do bazy danych są realizowane przez bibliotekę \textit{node-postgres}, która jest głównym silnikiem do tworzenia puli połączeń do bazy danych. Biblioteka ta jest rozszerzana przez bibliotekę \textit{DrizzleORM} w celu utworzenia Obiektowo Relacyjnego Mapowania struktur obiektów utworzonych w języku TypeScript na relacje bazy danych w języku SQL, napisania zoptymalizowanych zapytań do bazy danych, utworzenia migracji pomiędzy wersjami schematu tabel w procesie tworzenia aplikacji i jej wdrożenia, a także populowania bazy danych początkowymi danymi. Biblioteka \textit{DrizzleORM} charakteryzuje się zbliżoną semantyką, co język SQL, dzięki czemu dobra znajomość tworzenia zapytań przez zespół premiowała dobrą optymalizacją przepływu danych i prostszym, wydajniejszym modelem abstrakcji - każde poprawne zapytanie utworzone z użyciem \textit{DrizzleORM} jest konwertowane na dokładnie jedno zapytanie do bazy danych, a przygotowane wcześniej zapytania można było przepisać z małymi zmianami składni. Dzięki podejściu do połączenia z bazą danych z niewielką warstwą abstrakcji możliwe było wykorzystanie bardziej zaawansowanych funkcjonalności bazy danych PostgreSQL, takich jak m.in. użycie schematów jako dynamicznego zamiennika osobnych baz danych dla różnych, odseparowanych środowisk na tym samym serwerze, reprezentacja typów wyliczeniowych z użyciem \textit{pg\_enum} (m.in. do rodzajów koni i zdarzeń profilaktycznych), filtrowanie powiadomień do wysłania względem różnicy czasu wyliczanej po stronie silnika PostgreSQL, grupowanie kilku zapytań w jedno dzięki składni \textit{UNION} (powszechnie wykorzystywane przy pobieraniu zdarzeń profilaktycznych) i podzapytaniom z klauzulami \textit{NOT EXISTS} (do znalezienia czy istnieje domyślne zdjęcie dla danego konia przy usuwaniu), \textit{PARTITION BY} (do znalezienia najnowszych aktywnych zdarzeń profilaktycznych z każdej kategorii dla danego konia). \textit{DrizzleORM} jednocześnie dostarcza pełne interfejsy i typy danych oczekiwane przez język TypeScript, a nawet schematy walidacji do biblioteki walidacyjnej \textit{Zod}, dzięki dodatkowi \textit{drizzle-zod}. Pozwoliło to w procesie tworzenia aplikacji na zachowanie spójności w przepływie danych oraz zaoszczędzenie czasu na pisanie złożonych definicji schematów. Wykorzystanie biblioteki \textit{Zod} stanowi istotny element pracy, gdyż ze względu na zaawansowane i ergonomiczne funkcje walidacji, a także ogromną popularność biblioteka stała się standardem w środowisku TypeScript do tworzenia modeli danych. \textit{Zod} pozwala na zdefiniowanie schematów opisujących układ pól i ograniczenia danych, a następnie weryfikować wartości arbitralnych, niesprawdzonych obiektów przyjmowanych przez program, aby przetransformować lub potwierdzić poprawność z założonym formatem danych. Cenną funkcją biblioteki Zod jest zwracania szczegółowej, ustrukturyzowanej listy niezgodności ze schematem w trakcie walidacji. Zbiory powiązanych schematów można połączyć w rejestry, co pozwala powiązać je z dodatkowymi ustrukturyzowanymi metadanymi. Gotowe schematy można również obustronnie konwertować do formatu zgodnego ze specyfikacją JSON Schema, w tym OpenAPI. Wymieniona specyfikacja OpenAPI zapewnia spójny sposób przesyłania informacji na każdym etapie cyklu życia API. Jest to język specyfikacji dla interfejsów API HTTP, który definiuje strukturę i składnię w sposób niezalezny od języka programowania, w którym utworzono API. Ekosystem narzędzi powiązany z tym rozwiązaniem jest bardzo bogaty i dostarcza wiele rozwiązań generujących w pełni zautomatyzowany sposób gotową implementację (zdefiniowanej części sieciowej) klienta bądź serwera dla danej specyfikacji. Specyfikacje te są pisane w formatach YAML lub JSON, co umożliwia łatwe udostępnianie i ich wykorzystanie. Dzięki użyciu biblioteki \textit{@hono/zod-validator} możliwe było zdefiniowanie schematu danych przyjmowanych przez poszczególne endpointy API Hono z automatyczną walidacją niezależnie od formatu danych (query parameters, body jako json, czy form-data) z użyciem funkcji middleware \textit{zValidator}. Dodatkowo zestaw powiązanych bibliotek \textit{hono-openapi} i \textit{@hono/zod-openapi} pozwolił na dodanie adnotacji do dokumentacji danego endpointu w formacie OpenAPI oraz zdefiniowanie schematu zwracanych danych w zależności od kodu odpowiedzi. Wygenerowana dokumentacja w uniwersalnym formacie OpenAPI z całego backendu posłużyła jako wzorzec do tworzenia zapytań przez Gemini w procesie przetwarzania intencji użytkownika. Również dzięki interfejsowi graficznemu dostarczanemu przez bibliotekę \textit{Scalar} do obsługi dokumentacji OpenAPI niewielkim nakładem pracy utworzono zaawansowany panel administracyjny do zarządzania użytkownikami i stadninami przez administratorów. 

W celu zapewnienia bezpiecznego systemu uwierzytelniającego skorzystano z zewnętrznej biblioteki BetterAuth, która dostarczyła komponenty do zarządzania użytkownikami, kontami, hodowlami koni w kontekście organizacji i przynależnościami do nich. Integruje się on z DrizzleORM i tworzy automatycznie wymagane relacje w bazie danych. 


% tabele:
% - z aplikacji:
%     - zdjecia_koni
%     - choroby
%     - podkucia
%     - konie
%     - leczenia
%     - rozrody
%     - zdarzenia_profilaktycznego
%     - weterynarze
%     - kowale
%     - notifications
% - z better auth:
%     - organization
%     - invitation
%     - jwks
%     - verification
%     - member
%     - user
%     - session
%     - account
%     - apikey


Aplikacja posiada bogaty model danych, co ma swoje odniesienie w złożonym modelu encji związków. W celu zachowania jak najlepszej spójności zastosowano znormalizowaną postać bazy danych, a dla ułatwienia edycji głównego identyfikatora sztuczne klucze główne. Aplikacja została zaprojektowana z myślą, aby obsługiwać wiele oddzielnych hodowli na jednej instancji aplikacji w modelu architektury \english{multi-tenant}. Ze względu na to założenie wszystkie obiekty dodawane przez użytkowników muszą mieć powiązanie z daną hodowlą, której nadany identyfikator rodziela przynależność do danego klienta -- dzierżawcy. Postawową funkcjonalnością aplikacji jest zarządzanie końmi, w tym przypisanie im imion, nr paszportowych, istotnych dat, a także hodowli do której należą i innych danych charakterystycznych. Dodatkowo dla każdego konia można przypisać dowolną liczbę zdjęć, których podstawowe dane o przynależności są zapisywane w bazie danych (do którego konia, czy dane zdjęcie jest domyślne), natomiast same pliki zapisywane w oddzielnej usłudze zoptymalizowanej do przechowywania plików binarnych Google Cloud Storage w danym zasobniku. Dla każdego konia można przypisać wiele wydarzeń takich jak podkucia, choroby, leczenia, rozrody czy zdarzenia profilaktyczne. W przypadku podkuć, leczeń, rozrodów i zdarzeń profilaktycznych przypisywany jest również specjalista -- kowal lub weterynarz, powiązany z danym wydarzeniem. W przypadku specjalistów przechowywane dane są proste i ograniczają się do wskazania imienia, nazwiska, numeru telefonu i hodowli w jakiej zostali dodani. Do podkuć, chorób i zdarzeń profilaktycznych przypisane sa daty zdarzenia/rozpoczęcia oraz ważności/zakończenia, a do wszystkich wydarzeń poza podkuciami również opisy. Zdarzenia profilaktyczne posiadają również pole wyboru rodzaju zdarzenia spośród: odrobaczania, podania suplementów, szczepienia, dentysty i inne. Natomiast wydarzenia -- rozrody dzielą się na: inseminację konia, sprawdzenie źrebności, wyźrebienie i inne. Istotna jest również możliwość powiązania leczeń do danej choroby konia. Utworzona bezpośrednio została również tabela notifications, która przechowuje preferencje użytkownika dotyczące powiadamiania o zliżającym się końcu ważności danego wydarzenia z konfigurowalną liczbą dni wyprzedzenia, godziną powiadomienia i metodą wysłania. Pozostałe tabele zostały utworzone przez bibliotekę BetterAuth i służą do zarządzania użytkownikami i ich przynależnością do danej hodowli (organizacji), uwierzytelniania i kontroli dostępu. Tabela organization przechowuje informacje o hodowli, w tym dostępną liczbą zapytań do wykorzystania przez moduł asystenta. Poprzez relację N -- N member jest powiązana z tabelą user, co pozwala odszukać przynależność użytkownika do danej hodowli, a także sprawdzić rolę konta (administrator, konto zwykłe). Tabele account i apikey przechowują dane uwierzytelniające dla danego użytkownika, głównie wykorzystywane jest hasło do uwierzytelniania zwykłych kont, natomiast klucz API do dostępu administracyjnego. W tabeli session odnajdziemy informacje o aktywnych sesjach logowania użytkowników. Tabela verification przechowuje informacje o wysłanych e-mailach z potwierdzeniem po założeniu konta. Natomiast tabela invitation nie jest w praktyce wykorzystywana w projekcie i dotyczy zaproszeń użytkowników do organizacji przez innych użytkowników aplikacji (w praktyce dane konto użytkownika jest wyłącznie dla jednej organizacji).


\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/schemat-bazy.png}
\caption{Schemat bazy danych}\label{rys:schemat-bazy-danych}
\end{figure}


% Backend:
% - integruje różne systemy:
%     - zapis danych do bazy, a wyświetlanie ich na froncie w różnych formatach
%     - obsługuje zapytania do klasyfikatora i LLM
%     - wysyła okresowo powiadomienia email
%     - obsługuje generowanie linków do przesyłania zdjęć na bucket
% - obsługuje bezpośrednio:
%     - uwierzytelnianie i kontrolę dostępu z użyciem Better Auth:
%         - użytkownicy, hodowle (organizacje), sesje i hashe danych uwierzytelniających są zapisane w bazie danych z adapterem Drizzle
%         - sesja przechowywana jest jako ciasteczko sameSite: none,httpOnly: true, secure: true, partitioned: true, czyli niedostępne z poziomu kodu javascript po stronie klienta, następuje surowa walidacja czy nazwa domenowa nie uległa zmianie, wymusza protokół https i jest przechowywane osobno dla różnych kontekstów strony (wyłącznie dla api)
%         - wysyłanie potwierdzeń założenia konta, 
%     - logikę biznesową (CRUD, obliczenia ważności, generowanie raportów, przetwarzanie ustawień użytkowników)
%     - zadania okresowe CRON (wysyłanie powiadomień email o końcu ważności)
%     - współbieżny dostęp do danych z użyciem transakcji
%     - migracje i początkowe populacje bazy danych
% - jest silnie typowany w Typescript, ze schematem w Zod oraz relacjami bazy danych z DrizzleORM
% - można zapisać wszystkie jego endpointy do postaci OpenAPI, a także do klienta Hono RPC
% - jest zasadniczo bezstanowy, chociaż nie natywnie klastrowalny ze względu na cron joby (by były powtórzenia powiadomień)
% - napisany w Typescript, kompilowany do Javascript i uruchamiany w nodejs (distroless docker)
% - parametry konfiguracyjne zależne od środowiska są konfigurowane przez zmienne środowiskowe w pliku .env i bibliotekę dotenv
% - udostępnia statyczne pliki do klasyfikatora do załadowania testsetu
% - ma skonfigurowany jednolity logger requestów do API, zapytań do bazy danych, wydarzeń okresowych i innych operacji



\subsection{Mechanizmy bezpiczeństwa}

Bezpieczeństwo jest zapewniane przez protokół HTTPS poprzez wdrożenie aplikacji za reverse proxy, które jednocześnie centralizuje żądania do systemu i umożliwia niezależną skalowalność komponentów schowanych za nim. W przypadku tego projektu zdecydowano się na wybór Traefik, ze względu na wysoką wydajność przetwarzania zapytań, prostą konfigurację z dobrą integracją ze środowiskiem konteneryzacji Docker (w szczególności z Docker Compose) i zewnętrznym serwisem do wystawiania publicznie zaufanych certyfikatów TLS Let's Encrypt. 


\subsection{Wdrożenie i dystrybucja projektu}

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/repozytorium-zaleznosci-budowanie.png}
\caption{Struktura repozytorium kodu, uproszczony diagram zależności oraz tworzenia paczki dystrybucyjnej}\label{rys:repozytorium-zaleznosci-budowanie}
\end{figure}

Cały proces tworzenia paczki do dystrybucji dla części frontend jest złożony ze względu na optymalizację rozmiaru paczki, która to jest istotnym czynnikiem w szybkości ładowania strony, a także sztywny podział odpowiedzialności frontend - backend. Proces budowania przebiega następująco:
\begin{enumerate}
\item Kod w TypeScript z użyciem komponentów React w różnych plikach jest kompilowany do kodu w JavaScript (zmianę dodatkowych konstrukcji językowych na ich implementacje w JavaScript oraz pozbycie się typów), wyrażenia TailwindCSS zamieniane na klasy i dodawane do arkusza styli, a pliki multimedialne kopiowane bezpośrednio.
\item Kod w JavaScript i style CSS są minifikowane (krótkie arbitralne nazwy funkcji i plików, usuwanie pomijalnych białych znaków i komentarzy, przepisywanie wyrażeń na krótsze o równoważnym znaczeniu).
\item Zawartość plików jest przenoszona do innych plików o arbitralnych, unikalnych nazwach i stałym rozmiarze
\item Zależności są analizowane pod kątem wykorzystania funkcji, a nieużywany kod usuwany
\item Wynikowy katalog jest kopiowany do obrazu Dockera z web serwerem HTTP Nginx, który jest skonfigurowany do serwowania plików statycznych z maksymalnym cache oraz manifestem progresywnej aplikacji internetowej.
\end{enumerate}


\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/diagram-wdrozenia.png}
\caption{Diagram wdrożenia z użyciem Terraform i Ansible}\label{rys:diagram-wdrozenia}
\end{figure}

