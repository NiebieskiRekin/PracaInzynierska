\chapter{Architektura systemu}

\section{Założenia projektowe}

System \definicja{Moje Konie} został zaprojektowany z myślą o zapewnieniu pełnej kontroli nad zarządzaniem stajnią oraz umożliwieniu użytkownikom wygodnego monitorowania stanu i historii koni w hodowli. Podstawowym mechanizmem zabezpieczającym dostęp jest proces logowania, w którym użytkownik uwierzytelnia się przy użyciu adresu e-mail oraz hasła. Po poprawnym uwierzytelnieniu użytkownik uzyskuje autoryzację do wykonywania działań na obiektach przypisanych do jego hodowli. System zapewnia możliwość zmiany hasła przez użytkownika po podaniu aktualnego hasła i dwukrotnym wprowadzeniu nowego hasła. Treść hasła jest domyślnie maskowana, a użytkownik ma możliwość wyświetlenia tekstu jawnego podczas wpisywania. W przypadku podania nieprawidłowych danych uwierzytelniających system wyświetla odpowiedni komunikat błędu.

Po zalogowaniu użytkownik otrzymuje dostęp do przeglądania pełnej listy swoich koni, zawierających zdjęcie oraz nazwę konia. Wyświetlanie listy jest responsywne: na większych ekranach stosowane są trzy kolumny, natomiast na urządzeniach mobilnych tylko jedna. Lista koni wyposażona jest w wyszukiwarkę, pozwalającą na filtrowanie po nazwie poprzez wyszukanie fragmentu tekstu. Każda karta konia umożliwia przejście do ekranu ze szczegółowymi informacjami, gdzie użytkownik może zobaczyć numer przyżyciowy, numer chipa, rocznik urodzenia, rodzaj, płeć, datę przybycia i odejścia ze stajni, a także najnowsze aktywne wydarzenia związane z danym koniem, takie jak podkucia, szczepienia, odrobaczanie, podanie suplementów czy wizyty dentystyczne.

System pozwala na zarządzanie zdjęciami koni –- użytkownik może dodawać wiele zdjęć do jednego konia, a przełączanie między zdjęciami odbywa się za pomocą strzałek na ekranie szczegółów. Operacje dodawania i edycji koni odbywają się poprzez dedykowane formularze walidujące wymagane pola, natomiast usuwanie wymaga potwierdzenia ze strony użytkownika.

Na poziomie nawigacji system udostępnia moduły funkcjonalne obejmujące: zarządzanie końmi, weterynarzami, kowalami, wydarzeniami w stajni, asystentem oraz ustawieniami. Przy dodawaniu zdarzenia użytkownik wybiera jego typ, uzupełnia wymagane pola oraz wskazuje listę koni, do których zdarzenie ma zastosowanie. W celu wygodnej selekcji dostępny jest również przycisk pozwalający zaznaczyć wszystkie konie w danej stadninie. System podpowiada użytkownikowi powiązanych weterynarzy lub kowali przy dodawaniu zdarzeń wymagających ich udziału. Pod ostatnimi wydarzeniami znajduje się panel umożliwiający szybkie dodanie nowych wydarzeń, odpowiednio pogrupowanych według kategorii.

Dodatkowo użytkownik ma możliwość generowania raportów dla poszczególnych koni, w tym wyboru podzbioru wydarzeń oraz określenia zakresu czasowego według daty zdarzenia. System wysyła powiadomienia o zbliżającym się upływie ważności podkucia lub zdarzenia profilaktycznego. Użytkownik może określić preferencje powiadomień, w tym czas wyprzedzenia (w dniach i godzinach) oraz sposób doręczenia wiadomości (np. e-mail).

Projektując system, zwrócono szczególną uwagę na bezpieczeństwo, modularność oraz skalowalność. Dane autoryzacyjne przechowywane są w formie bezpiecznych hashy przy użyciu algorytmu \definicja{bcrypt}. System jest w stanie obsłużyć łącznie 400 użytkowników, w tym do 100 jednoczesnych sesji. Interfejs użytkownika został zaprojektowany w sposób intuicyjny i wygodny, działający zarówno w przeglądarce internetowej, jak i na urządzeniach mobilnych. Koszt utrzymania systemu jest minimalny, a administracja systemem prosta, co zwiększa długoterminową trwałość i niezawodność rozwiązania.

Wszystkie te cechy łącznie pozwalają na zapewnienie wysokiego poziomu bezpieczeństwa danych, przejrzystej organizacji informacji oraz wygodnej obsługi codziennych czynności w hodowli koni.


% TODO: Coś czego nie mamy (aby się nie walnąć):

% \begin{itemize}
%     \item resetowanie hasła przez użytkownika, tylko admin z dostępem do bazy danych (lub ogólnie całej instancji API)
%     \item rejestracja użytkowników przez użytkownika, j.w.
%     \item rejestracja hodowli przez użytkownika, j.w.
%     \item ustawienie złożoności hasła,
%     \item integracja z zewnętrznymi systemami uwierzytelniającymi
%     \item rate limiting prób logowania, ban po zbyt wielu próbach
%     \item utrzymywanie sesji logowania, sesja trwa 15 minut i się nie odświeża (coś było implementowane, ale nie działa)
%     \item wysyłanie powiadomień push (próbowałem dodać, nie udało mi się)
% \end{itemize}

% TODO: Błędy, które nie mogą nam umknąć:
% \begin{itemize}
%     \item Można powiększyć domyślne zdjęcie - jego brak
%     \item Miejscami zdarzenia są zapisywane jako wydarzenia i na odwrót
%     \item Koń po dodaniu ma jakiś pusty wpis ze zdjęciem, przez co cały czas się kręci, ale nic nie pokazuje
%     \item Przekierowanie z / do /konie nie działa
%     \item Czerwone komunikaty błędu na ciemnozielonym gradiencie tła są słabo widoczne (mają zbyt niski kontrast)
%     \item Tworzenie raportu dla konia bez wydarzeń nie działa (przykład koń aaa)
%     \item W ustawieniach powiadomień są wciąż opcje "Oba" i "Push", które nie działają w oczekiwany sposób
%     \item Wydarzenia są pobierane WSZYSTKIE NA RAZ a następnie stronnicowane i sortowane po stronie klienta
%     \item Walidacja w wielu miejscach odbywa się tylko po stronie klienta, np. nr telefonu
%     \item Chat po dodaniu nie ma odświeżanego stanu bazy danych np. dodanie konia, dodania szczepienia dla tego konia
% \end{itemize}


\section{Opis architektury aplikacji}

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/architektura-sieciowa}
\caption{Architektura sieciowa aplikacji}\label{rys:architektura-sieciowa}
\end{figure}

Ze względu na specyfikę aplikacji umożliwiającą edycję danych dotyczących danej hodowli koni wielu użytkownikom, w szczególności korzystających w większości z urządzeń mobilnych oraz sporadycznie z komputerów osobistych, zdecydowano się na formę systemu webowego z przeglądarkowym interfejsem użytkownika. Aplikacje internetowe pozwalają na wykorzystanie bogatego i dojrzałego zaplecza technologicznego do wyświetlania stron internetowych, co znacząco upraszcza aspekt dystrybucji oprogramowania oraz współbieżnego dostępu do danych.

Dla zachowania kompatybilności z technologią progresywnych aplikacji internetowych oraz modularności zdecydowano się na rozdzielenie warstwy przetwarzania logiki biznesowej z dostępem do danych, z którą użytkownik nie wchodzi w bezpośrednią interakcję - nazywaną backend, od warstwy bezpośrednio obsługującej interfejs użytkownika i wizualną prezentację danych - frontend. Obie warstwy nie komunikują się ze sobą, lecz współdziałają w celu tworzenia pełnej funkcjonalności aplikacji. Użytkownik inicuje wszelkie interakcje z obydwoma komponentami, choć zapytania do backendu są inicjowane w przeglądarce użytkownika wchodzącego w interakcję z frontendem, a także otrzymane dane i komunikaty diagnostyczne są wyłącznie obsługiwane przez ten komponent. Komunikacja odbywa się wyłącznie na warstwie 7 modelu ISO/OSI (warstwie aplikacji) za pomocą protokołu HTTP. Frontend obługuje żądania zwracając pliki HTML, CSS i JavaScript, natomiast backend działa w bezstanowej architekturze sieciowego interfejsu programowania REST zwracającego dane w formacie serializacji JSON. 




\subsection{Frontend}

Korzystając z technologii progresywnych aplikacji internetowych (ang. Progressive Web App, PWA) oraz praktyki responsywnego projektowania stron internetowych (ang. responsive web design, RWD) zaimplementowano spójny interfejs użytkownika dla platform mobilnych. Do implementacji technologii progresywnych aplikacji internetowych wymagane jest, aby interfejs graficzny użytkownika był skomponowany w zdecydowanej większości ze statycznych dokumentów hipertekstowych HTML (HyperText Markup Language), arkuszy stylów CSS (Cascading Style Sheets) oraz kodu w języku programowania JavaScript. Statyczne pliki w podanym kontekście oznaczają podleganie nieczęstym zmianom poprzez pobranie zaktualizowanej wersji z serwera - wyłącznie między oddzielnymi wydaniami aplikacji i nigdy w celu wyświetlenia nowych danych. Interaktywna prezentacja danych jest możliwa natomiast poprzez zmianę struktury wyświetlanego dokumentu hipertekstowego wykonywaną po stronie klienta z użyciem kodu JavaScript w przeglądarce. Wymienione działanie jest wykonywane poprzez interfejs programowania Document Object Model (DOM, pl. \textit{Model Obiektowy Dokumentu}) pozwalający na częściową lub pełną modyfikację dowolnego węzła (np. paragrafu tekstu, separatora, kontrolek, obiektu multimedialnego) w hierachicznej strukturze drzewa dokumentu HTML. Interfejs ten jest w praktyce wykorzystywany przez bibliotekę React, która nieco modyfikuje model z dokumentów HTML i skryptów JavaScript na komponenty wielokrotnego użytku (zawierające wymagane fragmenty dokumentu HTML i funkcje JavaScript) budujące deklaratywne widoki (strony internetowe). Komponenty można powiązać z danymi, czyli zaprojektować ich wygląd w celu prezentacji danych zgodnie z ich schematem oraz skonfigurować ich źródło, które będzie automatycznie odświeżane dążąc do zadeklarowanego stanu. Komponenty można w sobie zagnieżdżać, odtwarzając te same aspekty hierachicznej struktury, a ich zmiany są śledzone poprzez użycie wewnętrznej dla tej biblioteki kopii Modelu Obiektowego Dokumentu nazywanego Virtual DOM (pl. Wirtualny Model Obiektowy Dokumentu).

Opisane podejście nazywa się Aplikacją jednostronicową (ang. \textit{Single-page application, SPA}), co wynika głównie ze sposobu aktualizowania interfejsu na podstawie zmian w danych poprzez kod po stronie klienta i przesyłania statycznych dokumentów HTML, pomijając jednocześnie aspekt użycia wielu stron. W przypadku prezentowanej pracy rama projektowa została dostarczona przez bibliotekę React Router, która dostarcza pakiet budujący do Aplikacji jednostronicowej, dostarczając ponadto zestaw narzędzi służących do przechodzenia pomiędzy osobnymi widokami w zależności od użytego adresu URL - nazwany router, a także moduły do efektywnego pobierania danych w tle za pomocą funkcji asynchronicznych.


\subsection{Backend}

Backend:
- integruje różne systemy:
    - zapis danych do bazy, a wyświetlanie ich na froncie w różnych formatach
    - obsługuje zapytania do klasyfikatora i LLM
    - wysyła okresowo powiadomienia email
    - obsługuje generowanie linków do przesyłania zdjęć na bucket
- obsługuje bezpośrednio:
    - uwierzytelnianie i kontrolę dostępu z użyciem Better Auth:
        - użytkownicy, hodowle (organizacje), sesje i hashe danych uwierzytelniających są zapisane w bazie danych z adapterem Drizzle
        - sesja przechowywana jest jako ciasteczko httpOnly 
    - logikę biznesową (CRUD, obliczenia ważności, )
    - współbieżny dostęp do danych
    - migracje i początkowe populacje bazy danych
- jest silnie typowany w Typescript, ze schematem w Zod oraz relacjami bazy danych z DrizzleORM
- można zapisać wszystkie jego endpointy do postaci OpenAPI, a także do klienta Hono RPC
- jest zasadniczo bezstanowy, chociaż nie natywnie klastrowalny ze względu na cron joby (by były powtórzenia powiadomień)
- napisany w Typescript, kompilowany do Javascript i uruchamiany w nodejs (distroless docker)
- parametry konfiguracyjne zależne od środowiska są konfigurowane przez zmienne środowiskowe w pliku .env i bibliotekę dotenv




\subsection{Mechanizmy bezpiczeństwa}

Bezpieczeństwo jest zapewniane przez protokół HTTPS poprzez wdrożenie aplikacji za reverse proxy, które jednocześnie centralizuje żądania do systemu i umożliwia niezależną skalowalność komponentów schowanych za nim. W przypadku tego projektu zdecydowano się na wybór Traefik, ze względu na wysoką wydajność przetwarzania zapytań, prostą konfigurację z dobrą integracją ze środowiskiem konteneryzacji Docker (w szczególności z Docker Compose) i zewnętrznym serwisem do wystawiania publicznie zaufanych certyfikatów TLS Let's Encrypt. 


\subsection{Wdrożenie i dystrybucja projektu}

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/repozytorium-zaleznosci-budowanie.png}
\caption{Struktura repozytorium kodu, uproszczony diagram zależności oraz tworzenia paczki dystrybucyjnej}\label{rys:repozytorium-zaleznosci-budowanie}
\end{figure}

Cały proces tworzenia paczki do dystrybucji dla części frontend jest złożony ze względu na optymalizację rozmiaru paczki, która to jest istotnym czynnikiem w szybkości ładowania strony, a także sztywny podział odpowiedzialności frontend - backend. Proces budowania przebiega następująco:
\begin{enumerate}
\item Kod w TypeScript z użyciem komponentów React w różnych plikach jest kompilowany do kodu w JavaScript (zmianę dodatkowych konstrukcji językowych na ich implementacje w JavaScript oraz pozbycie się typów), wyrażenia TailwindCSS zamieniane na klasy i dodawane do arkusza styli, a pliki multimedialne kopiowane bezpośrednio.
\item Kod w JavaScript i style CSS są minifikowane (krótkie arbitralne nazwy funkcji i plików, usuwanie pomijalnych białych znaków i komentarzy, przepisywanie wyrażeń na krótsze o równoważnym znaczeniu).
\item Zawartość plików jest przenoszona do innych plików o arbitralnych, unikalnych nazwach i stałym rozmiarze
\item Zależności są analizowane pod kątem wykorzystania funkcji, a nieużywany kod usuwany
\item Wynikowy katalog jest kopiowany do obrazu Dockera z web serwerem HTTP Nginx, który jest skonfigurowany do serwowania plików statycznych z maksymalnym cache oraz manifestem progresywnej aplikacji internetowej.
\end{enumerate}


\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/diagram-wdrozenia.png}
\caption{Diagram wdrożenia z użyciem Terraform i Ansible}\label{rys:diagram-wdrozenia}
\end{figure}

