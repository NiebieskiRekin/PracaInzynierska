\chapter{Architektura systemu}

\section{Założenia projektowe}

System \definicja{Moje Konie} został zaprojektowany z myślą o zapewnieniu pełnej kontroli nad zarządzaniem stajnią oraz umożliwieniu użytkownikom wygodnego monitorowania stanu i historii koni w hodowli. Podstawowym mechanizmem zabezpieczającym dostęp jest proces logowania, w którym użytkownik uwierzytelnia się przy użyciu adresu e-mail oraz hasła. Po poprawnym uwierzytelnieniu użytkownik uzyskuje autoryzację do wykonywania działań na obiektach przypisanych do jego hodowli. System zapewnia możliwość zmiany hasła przez użytkownika po podaniu aktualnego hasła i dwukrotnym wprowadzeniu nowego hasła. Treść hasła jest domyślnie maskowana, a użytkownik ma możliwość wyświetlenia tekstu jawnego podczas wpisywania. W przypadku podania nieprawidłowych danych uwierzytelniających system wyświetla odpowiedni komunikat o błędzie.

Po zalogowaniu użytkownik otrzymuje dostęp do przeglądania pełnej listy swoich koni, zawierających zdjęcie oraz nazwę konia. Wyświetlanie listy jest responsywne: na większych ekranach stosowane są trzy kolumny, natomiast na urządzeniach mobilnych tylko jedna. Lista koni wyposażona jest w wyszukiwarkę, pozwalającą na filtrowanie po nazwie poprzez wyszukanie fragmentu tekstu. Każda karta konia umożliwia przejście do ekranu ze szczegółowymi informacjami, gdzie użytkownik może zobaczyć numer przyżyciowy, numer chipa, rocznik urodzenia, rodzaj, płeć, datę przybycia i odejścia ze stajni, a także najnowsze aktywne wydarzenia związane z danym koniem, takie jak podkucia, szczepienia, odrobaczanie, podanie suplementów czy wizyty dentystyczne. Wymieniony numer przyżyciowy to unikalny kod nadawany koniowi, zapisany w jego paszporcie, który wraz z numerem transpondera (chipa) i danymi właściciela służy do jego pełnej identyfikacji, zapobiegając nielegalnemu obrotowi, a także umożliwia śledzenie zdrowia, szczepień i pochodzenia.

System pozwala na zarządzanie zdjęciami koni –- użytkownik może dodawać wiele zdjęć do jednego konia, a przełączanie między zdjęciami odbywa się za pomocą strzałek na ekranie szczegółów. Operacje dodawania i edycji koni odbywają się poprzez dedykowane formularze walidujące wymagane pola, natomiast usuwanie wymaga potwierdzenia ze strony użytkownika.

Na poziomie nawigacji system udostępnia moduły funkcjonalne obejmujące: zarządzanie końmi, weterynarzami, kowalami, wydarzeniami w stajni, asystentem oraz ustawieniami. Przy dodawaniu zdarzenia użytkownik wybiera jego typ, uzupełnia wymagane pola oraz wskazuje listę koni, do których zdarzenie ma zastosowanie. W celu wygodnej selekcji dostępny jest również przycisk pozwalający zaznaczyć wszystkie konie w danej stadninie. System podpowiada użytkownikowi powiązanych weterynarzy lub kowali przy dodawaniu zdarzeń wymagających ich udziału. Pod ostatnimi wydarzeniami znajduje się panel umożliwiający szybkie dodanie nowych wydarzeń, odpowiednio pogrupowanych według kategorii.

Dodatkowo użytkownik ma możliwość generowania raportów dla poszczególnych koni, w tym wyboru podzbioru wydarzeń oraz określenia zakresu czasowego według daty zdarzenia. System wysyła powiadomienia o zbliżającym się upływie ważności podkucia lub zdarzenia profilaktycznego. Użytkownik może określić preferencje powiadomień, w tym czas wyprzedzenia (w dniach i godzinach) oraz sposób doręczenia wiadomości (np. e-mail).

Projektując system, zwrócono szczególną uwagę na bezpieczeństwo, modularność oraz skalowalność. Dane autoryzacyjne przechowywane są w formie bezpiecznych hashy. System jest w stanie obsłużyć łącznie 400 użytkowników, w tym do 100 jednoczesnych sesji. Interfejs użytkownika został zaprojektowany w sposób intuicyjny i wygodny, działający zarówno w przeglądarce internetowej, jak i na urządzeniach mobilnych. Koszt utrzymania systemu jest minimalny, a administracja systemem prosta, co zwiększa długoterminową trwałość i niezawodność rozwiązania.

Wszystkie te cechy łącznie pozwalają na zapewnienie wysokiego poziomu bezpieczeństwa danych, przejrzystej organizacji informacji oraz wygodnej obsługi codziennych czynności w hodowli koni.


% Coś czego nie mamy (aby się nie walnąć):
%  resetowanie hasła przez użytkownika, tylko poprzez admina
%  rejestracja użytkowników przez użytkownika, j.w.
%  rejestracja hodowli przez użytkownika, j.w.
%  ustawienie złożoności hasła,
%  integracja z zewnętrznymi systemami uwierzytelniającymi
%  wysyłanie powiadomień push (próbowałem dodać, nie udało mi się)


\section{Opis architektury aplikacji}

Ze względu na specyfikę aplikacji umożliwiającą edycję danych dotyczących danej hodowli koni wielu użytkownikom, w szczególności korzystających w większości z urządzeń mobilnych oraz sporadycznie z komputerów osobistych, zdecydowano się na formę systemu webowego z przeglądarkowym interfejsem użytkownika. Aplikacje internetowe pozwalają na wykorzystanie bogatego i dojrzałego zaplecza technologicznego do wyświetlania stron internetowych, co znacząco upraszcza aspekt dystrybucji oprogramowania oraz współbieżnego dostępu do danych.

Dla zachowania kompatybilności z technologią progresywnych aplikacji internetowych oraz modularności zdecydowano się na rozdzielenie warstwy przetwarzania logiki biznesowej z dostępem do danych, z którą użytkownik nie wchodzi w bezpośrednią interakcję -- nazywaną backend, od warstwy bezpośrednio obsługującej interfejs użytkownika i wizualną prezentację danych -- frontend. Użytkownik inicjuje wszelkie interakcje z obydwoma komponentami, choć zapytania do backendu są inicjowane w przeglądarce użytkownika wchodzącego w interakcję z frontendem, a także otrzymane dane i komunikaty diagnostyczne są wyłącznie obsługiwane przez ten komponent. Zapytania sieciowe służące pobraniu i aktualizacji danych inicjowane są poprzez moduł frontendu wykonywany w przeglądarce użytkownika odbywają się na warstwie 7 modelu ISO/OSI (warstwie aplikacji) za pomocą protokołu HTTPS. Z perspektywy działania serwera frontend obsługuje żądania zwracając pliki HTML, CSS i JavaScript, natomiast backend działa w bezstanowej architekturze sieciowego interfejsu programowania REST zwracającego dane w formacie serializacji JSON. 




\section{Frontend}

Korzystając z technologii progresywnych aplikacji internetowych (ang. Progressive Web App, PWA) oraz praktyki responsywnego projektowania stron internetowych (\english{responsive web design}, \akronim{RWD}) zaimplementowano spójny interfejs użytkownika dla platform mobilnych. Do implementacji technologii progresywnych aplikacji internetowych wymagane jest, aby interfejs graficzny użytkownika był skomponowany w zdecydowanej większości ze statycznych dokumentów hipertekstowych HTML (HyperText Markup Language), arkuszy stylów CSS (Cascading Style Sheets) oraz kodu w języku programowania JavaScript. Statyczne pliki w podanym kontekście oznaczają podleganie nieczęstym zmianom poprzez pobranie zaktualizowanej wersji z serwera -- wyłącznie między oddzielnymi wydaniami aplikacji i nigdy w celu wyświetlenia nowych danych.

Interaktywna prezentacja danych jest możliwa natomiast poprzez zmianę struktury wyświetlanego dokumentu hipertekstowego wykonywaną po stronie klienta z użyciem kodu JavaScript w przeglądarce. Wymienione działanie jest wykonywane poprzez interfejs programowania Document Object Model (DOM, pl. \textit{Model Obiektowy Dokumentu}) pozwalający na częściową lub pełną modyfikację dowolnego węzła (np. akapitu tekstu, separatora, kontrolek, obiektu multimedialnego) w hierarchicznej strukturze drzewa dokumentu HTML. Interfejs ten jest w praktyce wykorzystywany przez bibliotekę React, która nieco modyfikuje model z dokumentów HTML i skryptów JavaScript na komponenty wielokrotnego użytku (zawierające wymagane fragmenty dokumentu HTML i funkcje JavaScript) budujące deklaratywne widoki (strony internetowe). Komponenty można powiązać z danymi, czyli zaprojektować ich wygląd w celu prezentacji danych zgodnie z ich schematem oraz skonfigurować ich źródło, które będzie automatycznie odświeżane, dążąc do zadeklarowanego stanu. Komponenty można w sobie zagnieżdżać, odtwarzając te same aspekty hierarchicznej struktury, a ich zmiany są śledzone poprzez użycie wewnętrznej dla tej biblioteki kopii Modelu Obiektowego Dokumentu nazywanego Virtual DOM (pl. Wirtualny Model Obiektowy Dokumentu).

Opisane podejście nazywa się Aplikacją jednostronicową (\english{Single-page application}, \akronim{SPA}), co wynika głównie ze sposobu aktualizowania interfejsu na podstawie zmian w danych poprzez kod po stronie klienta i przesyłania statycznych dokumentów HTML, pomijając jednocześnie aspekt użycia wielu stron. W przypadku prezentowanej pracy rama projektowa (\english{framework}) została dostarczona przez bibliotekę React Router, która dostarcza narzędzie budujące (\english{build tool}) do aplikacji jednostronicowej, dostarczając ponadto zestaw narzędzi służących do przechodzenia pomiędzy osobnymi widokami w zależności od użytego adresu URL -- nazwany router, a także moduły do efektywnego pobierania danych w tle za pomocą funkcji asynchronicznych.


\section{Backend}

Przetwarzanie wykonywane po stronie serwera jest realizowane w znacznej części przez komponent backendu. Został on zaimplementowany jako bezstanowy interfejs programowania REST, który obsługuje komunikację za pomocą danych serializowanych do formatu JSON. Integruje on między sobą wiele komponentów, co zostało pokazane na diagramie architektury sieciowej, przedstawionym na Rysunku \ref{rys:architektura-sieciowa}. Jego głównym zadaniem jest udostępnienie dostępu do danych zapisanych w bazie danych przez protokół HTTP interfejsu sieciowego na warstwie 7 modelu ISO/OSI.

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/architektura-sieciowa}
\caption{Architektura sieciowa aplikacji}\label{rys:architektura-sieciowa}
\end{figure}

Rola serwera HTTP jest spełniana przez framework \textit{Hono}. Framework ten pozwala na bardzo modularne tworzenie silnie typowanych endpointów, warstw pośrednich przetwarzania (\english{middleware}) i elastyczne łączenie ich w poszczególne ścieżki obsługiwane współbieżnie i wydajnie przez jeden z kilku dostępnych silników dopasowań (\english{router}). % Usunąłem tekst o LinearRouter, bo znalazłem błąd w kodzie i złożyłem bug report do Hono - bardziej odpowiednie miejsce

Ze względu na wymóg współbieżnego, spójnego dostępu do danych o złożonych, ale stabilnych relacjach został wybrany system zarządzania relacyjną bazą danych \textit{PostgreSQL}. Spośród dostępnych na rynku rozwiązań wyróżnia się on brakiem opłat licencyjnych, bogatą dokumentacją, bardzo dobrą optymalizacją przetwarzania na małych i średnich zbiorach danych, obszernym zestawem funkcji, a także jest dobrze znana i lubiana przez zespół projektowy.

Zapytania do bazy danych są realizowane przez bibliotekę \textit{node-postgres}, która jest głównym silnikiem do tworzenia puli połączeń do bazy danych. Biblioteka ta jest rozszerzana przez bibliotekę \textit{DrizzleORM} w celu utworzenia odwzorowania obiektowo-relacyjnego (\akronim{ORM}, \english{Object-Relational mapping}) struktur obiektów utworzonych w języku TypeScript na relacje bazy danych w języku SQL, napisania zoptymalizowanych zapytań do bazy danych, utworzenia migracji pomiędzy wersjami schematu tabel w procesie tworzenia aplikacji i jej wdrożenia, a także wypełniania bazy danych początkowymi danymi. Biblioteka \textit{DrizzleORM} charakteryzuje się zbliżoną składnią, co język SQL, dzięki czemu dobra znajomość tworzenia zapytań przez zespół premiowała dobrą optymalizacją przepływu danych i prostszym, wydajniejszym modelem abstrakcji -- każde poprawne zapytanie utworzone z użyciem \textit{DrizzleORM} jest konwertowane na dokładnie jedno zapytanie do bazy danych, a przygotowane wcześniej zapytania można było przepisać z małymi zmianami składni. Dzięki podejściu do połączenia z bazą danych z niewielką warstwą abstrakcji możliwe było wykorzystanie bardziej zaawansowanych funkcjonalności bazy danych PostgreSQL, takich jak m.in. użycie schematów jako dynamicznego zamiennika osobnych baz danych dla różnych, odseparowanych środowisk na tym samym serwerze, reprezentacja typów wyliczeniowych z użyciem \textit{pg\_enum} (m.in. do rodzajów koni i zdarzeń profilaktycznych), filtrowanie powiadomień do wysłania względem różnicy czasu wyliczanej po stronie silnika PostgreSQL, grupowanie kilku zapytań w jedno dzięki składni \textit{UNION} (wykorzystywane przy pobieraniu zdarzeń profilaktycznych) i podzapytaniom z klauzulami \textit{NOT EXISTS} (do znalezienia czy istnieje domyślne zdjęcie dla danego konia przy usuwaniu), \textit{PARTITION BY} (do znalezienia najnowszych aktywnych zdarzeń profilaktycznych z każdej kategorii dla danego konia). \textit{DrizzleORM} jednocześnie dostarcza pełne interfejsy i typy danych oczekiwane przez język TypeScript, a nawet schematy walidacji do biblioteki walidacyjnej \textit{Zod}, dzięki dodatkowi \textit{drizzle-zod}. Pozwoliło to w procesie tworzenia aplikacji na zachowanie spójności w przepływie danych oraz zaoszczędzenie czasu na pisanie złożonych definicji schematów. Wykorzystanie biblioteki \textit{Zod} stanowi istotny element pracy, gdyż ze względu na zaawansowane i ergonomiczne funkcje walidacji, a także ogromną popularność biblioteka stała się standardem w środowisku TypeScript do tworzenia modeli danych. \textit{Zod} pozwala na zdefiniowanie schematów opisujących układ pól i ograniczenia danych, a następnie weryfikować wartości dowolnych, niesprawdzonych obiektów przyjmowanych przez program, aby przetransformować lub potwierdzić poprawność z założonym formatem danych. Cenną funkcją biblioteki \textit{Zod} jest zwracania szczegółowej, ustrukturyzowanej listy niezgodności ze schematem w trakcie walidacji. Zbiory powiązanych schematów można połączyć w rejestry, co pozwala powiązać je z dodatkowymi ustrukturyzowanymi metadanymi. Gotowe schematy można również obustronnie konwertować do formatu zgodnego ze specyfikacją JSON Schema, w tym OpenAPI. Wymieniona specyfikacja OpenAPI zapewnia spójny sposób przesyłania informacji na każdym etapie cyklu życia API. Jest to język specyfikacji dla interfejsów API HTTP, który definiuje strukturę i składnię w sposób niezależny od języka programowania, w którym utworzono API. Ekosystem narzędzi powiązany z tym rozwiązaniem jest bardzo bogaty i dostarcza wiele rozwiązań generujących w pełni zautomatyzowany sposób gotową implementację (zdefiniowanej części sieciowej) klienta bądź serwera dla danej specyfikacji. Specyfikacje te są pisane w formatach YAML lub JSON, co umożliwia łatwe udostępnianie i ich wykorzystanie. Dzięki użyciu biblioteki \texttt{@hono/zod-validator} dla każdej końcówki API Hono zdefiniowano schemat oczekiwanych danych. Wykorzystanie funkcji \texttt{zValidator} z tej samej biblioteki umożliwiło automatyczną walidację zgodności danych wejściowych ze schematem. Elastyczność rozwiązania powoduje, że walidacja jest przeprowadzana niezależnie czy dane są przekazywane jako element ścieżki wyszukiwania (\english{query parameters}), dane JSON w ciele żądania, czy zgodnie z typem \texttt{multipart/form-data} bądź \texttt{application/form-data}. Dodatkowo zestaw powiązanych bibliotek \textit{hono-openapi} i \textit{@hono/zod-openapi} pozwolił na dodanie adnotacji do dokumentacji danej końcówki w formacie OpenAPI oraz zdefiniowanie schematu zwracanych danych w zależności od kodu odpowiedzi. Wygenerowana dokumentacja w uniwersalnym formacie OpenAPI z całego backendu posłużyła jako wzorzec do tworzenia zapytań przez Gemini w procesie przetwarzania intencji użytkownika. Również dzięki interfejsowi graficznemu dostarczanemu przez bibliotekę \textit{Scalar} do obsługi dokumentacji OpenAPI niewielkim nakładem pracy utworzono zaawansowany panel administracyjny do zarządzania użytkownikami i stadninami przez administratorów. Został on przedstawiony dokładniej w rozdziale \ref{sec:panel-administracyjny}: \nameref{sec:panel-administracyjny}. Schematy \textit{Zod} wykorzystywane są również do walidacji konfiguracji zmiennych środowiskowych wymaganych do poprawnego działania aplikacji. 
% TODO: Uzupełnij odnośniki do rozdziału z wykorzystania Gemini

\subsection{Kontrola dostępu} \label{sec:kontrola-dostepu}

Aplikacja \definicja{Moje Konie} korzysta ze scentralizowanego, zintegrowanego z kodem aplikacji systemu uwierzytelniającego. W celu zapewnienia bezpiecznego systemu uwierzytelniającego skorzystano z zewnętrznej biblioteki BetterAuth, która dostarczyła komponenty do zarządzania użytkownikami, kontami, hodowlami koni w kontekście organizacji i przynależnościami do nich. Biblioteka wykorzystuje PostgreSQL jako magazyn danych i tworzy automatycznie wymagane relacje poprzez integracje z DrizzleORM. Konta użytkowników mogą zostać tworzone wyłącznie przez użytkownika z grupy administratorów, nie jest możliwa rejestracja zewnętrzna bezpośrednio przez użytkownika. Uwierzytelnianie odbywa się wyłącznie za pomocą adresu e-mail i hasła, a adresy e-mail muszą zostać potwierdzone poprzez link. Użytkownicy mają możliwość zmiany ustawionego hasła, a po zakończeniu tego procesu następuje unieważnienie wszystkich aktywnych sesji, co powstrzymuje przed dostępem z potencjalnie przejętych urządzeń.

Zarządzanie sesjami realizowane jest poprzez mechanizm ciasteczek i zapisanie aktywnych sesji w bazie danych. W celu optymalizacji wydajności i redukcji obciążenia bazy danych przy sekwencyjnych żądaniach wykorzystano mechanizm pamięci podręcznej ciasteczek wynoszący 5 minut. Dzięki temu backend zamiast wypytywać bazę danych dla każdego przychodzącego żądania wymagającego uwierzytelnienia może potwierdzić daną sesję z ciasteczka podpisanego kryptograficznie. Takie ciasteczko trafia następnie do przeglądarki użytkownika. Podpisy i potwierdzenia są realizowane przez backend z użyciem tajnego symetrycznego klucza (wyłącznie po stronie serwera) z użyciem funkcji skrótu \emph{HMAC-SHA256}. Po upłynięciu ustalonego czasu wygaśnięcia pamięci podręcznej kolejne żądanie wymagające uwierzytelnienia będzie powodowało utworzenia zapytania do bazy danych o potwierdzenie sesji użytkownika i generowało nowe podpisane ciasteczko. Sesje użytkowników mają długi czas wygasania wynoszący 30 dni, w którego trakcie ważność sesji jest automatycznie odświeżana przy aktywności użytkownika raz na 24 godziny. Ma to na celu utrzymywanie poprawnej sesji (stanu bycia zalogowanym do strony) na czas dostatecznie długi, aby nie stanowił problemu dla aktywnych i powracających po niedługich odstępach czasu użytkowników, a jego długość jest podyktowana zarządzaniem danymi o nieczęstej zmienności i niską potrzebą codziennego pobierania danych przez użytkowników. Pozostałe aspekty ciasteczek sesyjnych skonfigurowano z naciskiem na bezpieczeństwo. Flaga \emph{SameSite} ustawiona na \emph{Strict} wymusza pełną zgodność nazwy domenowej serwera, z którym następuje połączenie w odniesieniu do serwera, który ustawił dane ciasteczko, co pomaga zapobiegać atakom polegającym na wymuszaniu nieautoryzowanej akcji w przeglądarce ofiary takim jak \emph{Cross Site Request Forgery} (\akronim{CSRF}). Atrybut \emph{HttpOnly} zabrania dostępu do wartości danego ciasteczka sesji przez kod JavaScript w przeglądarce klienta, co ponownie zawęża możliwe ataki z użyciem złośliwych skryptów takie jak \emph{Cross Site Scripting} (\akronim{XSS}). Finalnie flagi \emph{Secure} oraz \emph{Partitioned} są skonfigurowane zgodnie z zaleceniami przeglądarek i wymuszają odpowiednio poufność przez konieczność stosowania protokołu HTTPS, oraz izolację sesji użytkownika zgodnie z wytycznymi prywatności.

Warstwa autoryzacji wykorzystuje model kontroli dostępu opartej na 2 rolach (admin, user) oraz strukturę wielodostępową (\english{multi-tenancy}) poprzez tworzenie organizacji do zarządzania odrębnymi hodowlami. Domyślna rola użytkownika pozwala na zarządzanie cyklem życia (dodawanie, usuwanie, edycja) wszystkich zwykłych obiektów takich jak: konie, wydarzenia z nimi związane, zapisani specjaliści, a także ustawienia użytkownika. Rola administratora jest przeznaczona dla osób posiadających odpowiednie kompetencje do zarządzania całą instancją serwera, a zatem pozwala na dodawanie nowych i edycję istniejących kont użytkowników, hodowli, danych uwierzytelniających i wszystkie uprawnienia nadane podstawowej roli użytkownika. Dodatkowo włączono obsługę kluczy API, są to jednoskładnikowe dane uwierzytelniające służące do obsługi żądań do API poprzez interfejsy programistyczne i może być wykorzystywane do automatyzacji części procesów aplikacji z zewnętrznymi usługami, a także posłużyć jako składnik uwierzytelniający w panelu administracyjnym. Pełen zestaw funkcji jest zawarty w dokumentacji w specyfikacji OpenAPI \cite{TODO}. Warstwa autoryzacji integruje się z serwerem utworzonym przez framework \textit{Hono} poprzez udostępnienie końcówek autoryzacyjnych pod ścieżką \texttt{/api/auth}. Dzięki wykorzystaniu gotowego zestawu tłumaczeń komunikaty błędów funkcji \textit{BetterAuth} zostały przetłumaczone na język polski. W celu poprawy widoczności informacji diagnostycznych o incydentach kluczowe zdarzenia bezpieczeństwa są rejestrowane.

% tabele:
% - z aplikacji:
%     - zdjecia_koni
%     - choroby
%     - podkucia
%     - konie
%     - leczenia
%     - rozrody
%     - zdarzenia_profilaktycznego
%     - weterynarze
%     - kowale
%     - notifications
% - z better auth:
%     - organization
%     - invitation
%     - jwks
%     - verification
%     - member
%     - user
%     - session
%     - account
%     - apikey

\subsection{Baza danych}

Aplikacja posiada bogaty model danych, co ma swoje odniesienie w złożonym modelu encji związków przedstawionym na Rysunku \ref{rys:schemat-bazy-danych}. W celu zachowania jak najlepszej spójności zastosowano znormalizowaną postać bazy danych, a dla ułatwienia edycji głównego identyfikatora sztuczne klucze główne. Aplikacja została zaprojektowana z myślą, aby obsługiwać wiele oddzielnych hodowli na jednej instancji aplikacji w modelu architektury wielodostępowej (\english{multi-tenant}). Ze względu na to założenie wszystkie obiekty dodawane przez użytkowników muszą mieć powiązanie z daną hodowlą, której nadany identyfikator rozdziela przynależność do danego klienta -- dzierżawcy. Podstawową funkcjonalnością aplikacji jest zarządzanie końmi, w tym przypisanie im imion, nr paszportowych, istotnych dat, a także hodowli, do której należą i innych danych charakterystycznych. Dodatkowo dla każdego konia można przypisać dowolną liczbę zdjęć, których podstawowe dane o przynależności są zapisywane w bazie danych (do którego konia, czy dane zdjęcie jest domyślne), natomiast same pliki są zapisywane w oddzielnej usłudze zoptymalizowanej do przechowywania plików binarnych \emph{Google Cloud Storage} w danym zasobniku co zostało opisane dokładniej w rozdziale \ref{sec:gcs}: \nameref{sec:gcs}.

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/schemat-bazy.png}
\caption{Schemat bazy danych}\label{rys:schemat-bazy-danych}
\end{figure}


Dla każdego konia można przypisać wiele wydarzeń takich jak podkucia, choroby, leczenia, rozrody czy zdarzenia profilaktyczne. W przypadku podkuć, leczeń, rozrodów i zdarzeń profilaktycznych przypisywany jest również specjalista -- kowal lub weterynarz, powiązany z danym wydarzeniem. W przypadku specjalistów przechowywane dane są proste i ograniczają się do wskazania imienia, nazwiska, numeru telefonu i hodowli, w jakiej zostali dodani. Do podkuć, chorób i zdarzeń profilaktycznych przypisane są daty zdarzenia/rozpoczęcia oraz ważności/zakończenia, a do wszystkich wydarzeń poza podkuciami również opisy. Zdarzenia profilaktyczne posiadają również pole wyboru rodzaju zdarzenia spośród: odrobaczania, podania suplementów, szczepienia, dentysty i inne. Natomiast wydarzenia -- rozrody dzielą się na: inseminację konia, sprawdzenie źrebności, wyźrebienie i inne. Istotna jest również możliwość powiązania leczeń do danej choroby konia. Utworzona bezpośrednio została również tabela \emph{notifications}, która przechowuje preferencje użytkownika dotyczące powiadamiania o zbliżającym się końcu ważności danego wydarzenia z konfigurowalną liczbą dni wyprzedzenia, godziną powiadomienia i metodą wysłania.

Pozostałe tabele zostały utworzone przez bibliotekę BetterAuth i służą do zarządzania użytkownikami i ich przynależnością do danej hodowli (organizacji), uwierzytelniania i kontroli dostępu. Tabela \emph{organization} przechowuje informacje o hodowli, w tym dostępną liczbą zapytań do wykorzystania przez moduł asystenta. Tabela \emph{member} reprezentuje relację wiele do wielu pomiędzy tabelami \emph{organization} a \emph{user}, co pozwala odszukać przynależność użytkownika do danej hodowli, a także sprawdzić rolę konta (administrator, konto zwykłe). Tabele \emph{account} i \emph{apikey} przechowują dane uwierzytelniające dla danego użytkownika, głównie wykorzystywane jest hasło do uwierzytelniania zwykłych kont, natomiast klucz API do dostępu administracyjnego. W tabeli \emph{session} odnajdziemy informacje o aktywnych sesjach logowania użytkowników. Tabela \emph{verification} przechowuje informacje o wysłanych e-mailach z potwierdzeniem po założeniu konta. Natomiast tabela \emph{invitation} nie jest w praktyce wykorzystywana w projekcie i dotyczy zaproszeń użytkowników do organizacji przez innych użytkowników aplikacji (w praktyce dane konto użytkownika jest wyłącznie dla jednej organizacji).



% Backend:
% - integruje różne systemy:
%     - zapis danych do bazy, a wyświetlanie ich na froncie w różnych formatach
%     - obsługuje zapytania do klasyfikatora i LLM
%     - wysyła okresowo powiadomienia email
%     - obsługuje generowanie linków do przesyłania zdjęć na bucket
% - obsługuje bezpośrednio:
%     - uwierzytelnianie i kontrolę dostępu z użyciem Better Auth:
%         - użytkownicy, hodowle (organizacje), sesje i hashe danych uwierzytelniających są zapisane w bazie danych z adapterem Drizzle
%         - sesja przechowywana jest jako ciasteczko sameSite: none,httpOnly: true, secure: true, partitioned: true, czyli niedostępne z poziomu kodu javascript po stronie klienta, następuje surowa walidacja czy nazwa domenowa nie uległa zmianie, wymusza protokół https i jest przechowywane osobno dla różnych kontekstów strony (wyłącznie dla api)
%         - wysyłanie potwierdzeń założenia konta, 
%     - logikę biznesową (CRUD, obliczenia ważności, generowanie raportów, przetwarzanie ustawień użytkowników)
%     - zadania okresowe CRON (wysyłanie powiadomień email o końcu ważności)
%     - współbieżny dostęp do danych z użyciem transakcji
%     - migracje i początkowe populacje bazy danych
% - jest silnie typowany w Typescript, ze schematem w Zod oraz relacjami bazy danych z DrizzleORM
% - można zapisać wszystkie jego endpointy do postaci OpenAPI, a także do klienta Hono RPC
% - jest zasadniczo bezstanowy, chociaż nie natywnie klastrowalny ze względu na cron joby (by były powtórzenia powiadomień)
% - napisany w Typescript, kompilowany do Javascript i uruchamiany w nodejs (distroless docker)
% - parametry konfiguracyjne zależne od środowiska są konfigurowane przez zmienne środowiskowe w pliku .env i bibliotekę dotenv
% - udostępnia statyczne pliki do klasyfikatora do załadowania testsetu
% - ma skonfigurowany jednolity logger requestów do API, zapytań do bazy danych, wydarzeń okresowych i innych operacji

\section{Google Cloud Storage} \label{sec:gcs}

\textit{Google Cloud Storage} jest usługą oferowaną i zarządzaną przez firmę \textit{Google}, w ramach której otrzymujemy dostęp do magazynu obiektowego (\english{Object Storage}). Różni się on od tradycyjnego systemu plików (jak dysk twardy z drzewem katalogów) tym, że dane istnieją w płaskiej strukturze wewnątrz danego \textit{zasobnika}. Zasobnik jest wydzieloną częścią usługi przydzieloną do danego projektu i funkcjonuje jako kontener bez dalszej hierarchii. Zasobniki posiadają globalnie unikalne nazwy, są przypisane do określonego regionu geograficznego, a także definiują polityki dostępu. 

Dane zapisywane do zasobnika są reprezentowane jako \textit{obiekty}. Odpowiadają one plikom, takim jak zdjęcia czy dokumenty tekstowe, bez ograniczeń dotyczących wewnętrznej struktury danych -- każdy format jest akceptowalny. O ile usługa potrafi wyświetlać przesłane obiekty w formie przypominającej katalogi, to w rzeczywistości struktura jest płaska, a foldery są odtwarzane wirtualnie na podstawie ukośników w nazwach plików. Dodatkowo obiekty w ramach magazynu nie są edytowalne fragmentami, a mogą być jedynie nadpisywane w całości, co pozwala na ich automatyczne wersjonowanie.

W aplikacji \definicja{Moje Konie} usługa magazynu obiektowego jest wykorzystywana do przechowywania zdjęć koni i udostępniania ich użytkownikom. W tym celu zaimplementowano wzorzec bezpośredniego dostępu autoryzowanego. Aby zoptymalizować wydajność i zredukować obciążenie sieciowe serwera (backendu), operacje przesyłania i pobierania plików zostały oddelegowane bezpośrednio do infrastruktury \textit{Google} z wykorzystaniem mechanizmu \textit{podpisanego odnośnika} (\english{Signed URL}). Aplikacja korzysta z biblioteki \texttt{@google-cloud/storage}, która upraszcza implementację tego procesu. Mechanizm udostępniania zasobów składa się z trzech kroków:

\begin{enumerate}
    \item \textbf{Konfiguracja tożsamości i kluczy}: Uwierzytelnianie procesu podpisywania odbywa się z użyciem pary kluczy asymetrycznych. Backend posiada klucz prywatny oraz identyfikator konta usługi (\english{Service Account}), które tworzą jego tożsamość ładowaną podczas startu aplikacji. Konto to posiada nadane uprawnienia do zarządzania zasobnikiem. Weryfikacja tych uprawnień nie następuje w momencie generowania linku przez backend, lecz jest odroczona do momentu faktycznej próby dostępu przez klienta.
    
    \item \textbf{Generowanie podpisanego żądania}: Gdy użytkownik chce wykonać operację na obiekcie, backend nie łączy się z usługą \textit{Google Cloud Storage}. Zamiast tego przygotowuje autoryzację zgodnie ze standardem \textit{GOOG4-RSA-SHA256} \cite{TODO}. Proces ten polega na zamianie parametrów planowanego żądania HTTP (metody, ścieżki do zasobu, nagłówków i czasu wygaśnięcia) w znormalizowany ciąg znaków. Następnie ciąg ten przekształcany jest w skrót \textit{SHA-256}, który zostaje zaszyfrowany kluczem prywatnym backendu. Ten zaszyfrowany skrót stanowi kryptograficzny podpis dołączany do adresu URL. Utworzony odnośnik ma ograniczony czas ważności, co minimalizuje ryzyko nieuprawnionego dostępu w przypadku jego przechwycenia.
    
    \item \textbf{Weryfikacja i transfer danych}: Klient (frontend) po otrzymaniu \textit{podpisanego odnośnika} wykonuje żądanie bezpośrednio do serwerów \textit{Google Cloud Storage}. W tym momencie infrastruktura chmury weryfikuje podpis, używając klucza publicznego przypisanego do konta usługi, oraz sprawdza ważność linku i uprawnienia. Jakakolwiek ingerencja w parametry adresu URL spowoduje niezgodność z podpisem i odrzucenie żądania. Po pomyślnej autoryzacji następuje transfer danych bezpośrednio między urządzeniem użytkownika a chmurą, z całkowitym pominięciem serwera aplikacji.
\end{enumerate}


% \subsection{Mechanizmy bezpiczeństwa}

% Traefik
% Docker
% Distroless / hardened images
% Cloudflare
% Firewall
% Ciasteczka?
% Better auth?
% 

% Bezpieczeństwo jest zapewniane przez protokół HTTPS poprzez wdrożenie aplikacji za reverse proxy, które jednocześnie centralizuje żądania do systemu i umożliwia niezależną skalowalność komponentów schowanych za nim. W przypadku tego projektu zdecydowano się na wybór Traefik, ze względu na wysoką wydajność przetwarzania zapytań, prostą konfigurację z dobrą integracją ze środowiskiem konteneryzacji Docker (w szczególności z Docker Compose) i zewnętrznym serwisem do wystawiania publicznie zaufanych certyfikatów TLS Let's Encrypt. 


\section{Wdrożenie i dystrybucja projektu}

Tekst, aby przesunąć obrazki.

% W github actions uruchamiany jest tsc i vite. Pliki *.js i definicja openapi jest kopiowana do obrazu backendu ...

\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/repozytorium-zaleznosci-budowanie.png}
\caption{Struktura repozytorium kodu, uproszczony diagram zależności oraz tworzenia paczki dystrybucyjnej}\label{rys:repozytorium-zaleznosci-budowanie}
\end{figure}

% Cały proces tworzenia paczki do dystrybucji dla części frontend jest złożony ze względu na optymalizację rozmiaru paczki, która to jest istotnym czynnikiem w szybkości ładowania strony, a także sztywny podział odpowiedzialności frontend - backend. Proces budowania przebiega następująco:
% \begin{enumerate}
% \item Kod w TypeScript z użyciem komponentów React w różnych plikach jest kompilowany do kodu w JavaScript (zmianę dodatkowych konstrukcji językowych na ich implementacje w JavaScript oraz pozbycie się typów), wyrażenia TailwindCSS zamieniane na klasy i dodawane do arkusza styli, a pliki multimedialne kopiowane bezpośrednio.
% \item Kod w JavaScript i style CSS są minifikowane (krótkie arbitralne nazwy funkcji i plików, usuwanie pomijalnych białych znaków i komentarzy, przepisywanie wyrażeń na krótsze o równoważnym znaczeniu).
% \item Zawartość plików jest przenoszona do innych plików o arbitralnych, unikalnych nazwach i stałym rozmiarze
% \item Zależności są analizowane pod kątem wykorzystania funkcji, a nieużywany kod usuwany
% \item Wynikowy katalog jest kopiowany do obrazu Dockera z web serwerem HTTP Nginx, który jest skonfigurowany do serwowania plików statycznych z maksymalnym cache oraz manifestem progresywnej aplikacji internetowej.
% \end{enumerate}


\begin{figure}[t]
\centering\includegraphics[width=\textwidth]{figures/diagram-wdrozenia.png}
\caption{Diagram wdrożenia z użyciem Terraform i Ansible}\label{rys:diagram-wdrozenia}
\end{figure}

