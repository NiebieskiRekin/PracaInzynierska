\chapter{Architektura systemu}

\section{Założenia projektowe}

Zaprojektowany system spełnia następujące wymagania funkcjonalne:

\begin{itemize}
    \item Użytkownika może się uwierzytelnić na ekranie logowania.
    \item Po pomyślnym uwierzytelnieniu użytkownik jest autoryzowany do podejmowania działań na obiektach należących do wskazanej hodowli.
    \item Użytkownika ma możliwość zmiany składnika uwierzytelniającego (hasła).
    \item Użytkownik po zalogowaniu może zobaczyć wszystkie swoje konie (przypisane dla danej hodowli), 
    \item Strona pokazująca listę koni udostępnia wyszukiwarkę, za pomocą której można filtrować wyświetlanie konie.
    \item Strona z listą koni umożliwia przejście do strony z informacjami szczegółowymi danego konia.
    \item System umożliwia podejrzenie zdjęcia konia i jego powiększenie.
\end{itemize}


Wymagania pozafunkcjonalne (co mi przyjdzie to piszę):

\begin{itemize}
    \item Logowanie użytkownika odbywa się poprzez email oraz hasło.
    \item Do zmiany hasła wymagane jest podanie starego hasła oraz dwukrotne podanie nowego hasła.
    \item Treść hasła jest domyślnie maskowana na ekranie logowania, użytkownik może ją podejrzeć podczas wpisywania.
    \item przechowywanie danych autoryzacji w sposób bezpieczny, wyłącznie hashe bcrypt haseł,
    \item Lista koni jest wyświetlana jako karty ze zdjęciem i nazwą konia. W formacie przeznaczonym na większe ekrany są to 3 kolumny, natomiast na urządzeniach mobilnych jest to 1 kolumna.
    \item Po zalogowaniu wyświetlana jest lista koni.
    \item Filtrowanie koni na liście odbywa się po nazwie za pomocą wyszukania podciągu znaków frazy.
    \item Ekran pokazujący zdjęcie konia jest 
\end{itemize}

Coś czego nie mamy (aby się nie walnąć):

\begin{itemize}
    \item resetowanie hasła przez użytkownika, tylko admin z dostępem do bazy danych (lub ogólnie całej instancji API)
    \item rejestracja użytkowników przez użytkownika, j.w.
    \item rejestracja hodowli przez użytkownika, j.w.
    \item ustawienie złożoności hasła,
    \item integracja z zewnętrznymi systemami uwierzytelniającymi
    \item rate limiting prób logowania, ban po zbyt wielu próbach
    \item utrzymywanie sesji logowania, sesja trwa 15 minut i się nie odświeża (coś było implementowane, ale nie działa)
\end{itemize}



... pozafunkcjonalnych, wynikających zarówno z charakteru domeny, jak i przewidywanego sposobu eksploatacji. Do najważniejszych należą:

\begin{itemize}
    \item niski koszt utrzymania długoterminowego, preferencyjnie z wykorzystaniem bezpłatnych technologii open-source,
    \item niewielki narzut czasowy na operacje administracyjne i utrzymaniowe,
    \item wydajność wystarczająca do obsługi do 400 użytkowników, w tym około 100 jednoczesnych,
    \item wysoki poziom bezpieczeństwa, modularność i izolacja komponentów systemu, co ułatwia migrację i minimalizuje potencjalny obszar nadużyć,
    \item intuicyjny i wygodny interfejs graficzny, działający w przeglądarce internetowej oraz jako aplikacja mobilna w technologii PWA.
\end{itemize}



\section{Uzasadnienie wyboru architektury webowej}

Ze względu na specyfikę aplikacji umożliwiającą edycję danych dotyczących danej hodowli koni wielu użytkownikom, w szczególności korzystających w większości z urządzeń mobilnych oraz sporadycznie z komputerów osobistych, zdecydowano się na formę systemu webowego z interfejsem użytkownika dostępnym w przeglądarce. Dostęp do usługi z wykorzystaniem przeglądarki do wyświeltania interfejsu użytkownika pozwala na wykorzystanie bogatego i dojrzałego zaplecza technologicznego do wyświetlania stron internetowych, znacząco upraszcza aspekt dystrybucji oprogramowania oraz współczesnego dostępu do danych. 
Korzystając z technologii progresywnych aplikacji internetowych (ang. Progressive Web App, PWA) oraz praktyki responsywnego projektowania stron internetowych (ang. responsive web design, RWD) zaimplementowano spójny interfejs użytkownika dla platform mobilnych. Do implementacji technologii progresywnych aplikacji internetowych wymagane jest, aby interfejs graficzny użytkownika był skomponowany w zdecydowanej większości ze statycznych (podlegających nieczęstym zmianom i niezmienialnych) dokumentów hipertekstowych HTML (HyperText Markup Language), arkuszy stylów CSS (Cascading Style Sheets) oraz kodu w języku programowania Javascript. Dla zachowania kompatybilności z technologią progresywnych aplikacji internetowych oraz modularności zdecydowano się na rozdzielenie ich na osobne procesy. 

\section{Frontend}

Warstwa frontendowa odpowiada za wizualną prezentację danych i interakcję użytkownika z systemem. Została zaprojektowana jako aplikacja typu SPA (Single Page Application), wykorzystująca nowoczesne technologie webowe.

\subsection{React Router}

Do implementacji routingu po stronie klienta wykorzystano framework React Router. Zapewnia on:

\begin{itemize}
    \item lekkość i prostotę konfiguracji,
    \item obsługę renderowania po stronie klienta,
    \item wsparcie dla React 18 oraz React 19,
    \item możliwość zarówno minimalnego, jak i kompleksowego wykorzystania w aplikacji.
\end{itemize}

React Router korzysta z bibliotek i narzędzi: React, TypeScript, Vite oraz Nginx. Projekt uzupełniają również VitePWA, Zod oraz Tailwind CSS.

\subsection{React}

React pełni rolę biblioteki odpowiedzialnej za budowę interfejsu. Został wybrany ze względu na:

\begin{itemize}
    \item bardzo dużą popularność i wsparcie społeczności,
    \item prostotę i deklaratywny model programowania,
    \item komponentową strukturę umożliwiającą skalowanie aplikacji,
    \item możliwość ponownego wykorzystania kodu,
    \item znajomość technologii przez zespół projektowy.
\end{itemize}

React umożliwia tworzenie złożonych interfejsów przy użyciu komponentów zarządzających własnym stanem, z możliwością integracji z TypeScript i narzędziami budującymi.

\subsection{TypeScript}

TypeScript został wykorzystany w celu rozszerzenia języka JavaScript o statyczny system typów, co zapewnia:

\begin{itemize}
    \item poprawę jakości kodu,
    \item redukcję błędów wykonania,
    \item lepsze narzędzia developerskie (np. IntelliSense),
    \item kompatybilność z nowoczesnymi bibliotekami frontendowymi.
\end{itemize}

\subsection{Vite}

Vite jest narzędziem developerskim i bundlerem zaprojektowanym z myślą o optymalnej wydajności.

\begin{itemize}
    \item Bardzo szybki serwer deweloperski oparty o moduły ES.
    \item Obsługa natychmiastowego przeładowania (HMR).
    \item Integracja z Rollup na potrzeby kompilacji produkcyjnej.
    \item Wsparcie dla PWA poprzez plugin VitePWA.
\end{itemize}

\subsection{Zod}

Zod jest biblioteką walidacji danych typu TypeScript-first. Zapewnia:

\begin{itemize}
    \item spójne walidowanie danych po obu stronach aplikacji,
    \item bogaty system błędów i prosty interfejs API,
    \item integrację z narzędziami backendowymi i ORM,
    \item generowanie schematów JSON Schema oraz OpenAPI.
\end{itemize}

\subsection{Tailwind CSS}

Tailwind CSS został użyty do budowy warstwy prezentacji poprzez zestaw niskopoziomowych klas użytkowych, co umożliwia szybkie prototypowanie oraz utrzymanie spójnej stylistyki interfejsu.

\subsection{Nginx}

W środowisku produkcyjnym frontend jest udostępniany przez serwer Nginx. Wybrano go ze względu na:

\begin{itemize}
    \item wysoką wydajność,
    \item niewielki narzut zasobów,
    \item bogatą funkcjonalność mimo niewielkiego rozmiaru,
    \item sprawdzone działanie i dojrzałość technologii.
\end{itemize}

\section{Backend}

Backend realizuje logikę biznesową aplikacji, odpowiada za dostęp do bazy danych, uwierzytelnianie użytkowników oraz komunikację z usługami zewnętrznymi.

\subsection{Hono}

Hono jest lekkim frameworkiem webowym zgodnym ze standardami Web Standards, działającym na wielu środowiskach wykonawczych. Najważniejsze cechy:

\begin{itemize}
    \item bardzo wysoka wydajność routera,
    \item brak zewnętrznych zależności,
    \item obsługa środowisk Node.js, Deno, Bun, Cloudflare Workers i innych,
    \item szeroki zestaw wbudowanych middleware’ów,
    \item pełne wsparcie dla TypeScript.
\end{itemize}

Hono pełni rolę warstwy REST API oraz kanału RPC umożliwiającego komunikację z frontendem z wykorzystaniem wspólnych schematów danych.

\subsection{Zod w backendzie}

Podobnie jak we frontendzie, Zod odpowiada za walidację danych wejściowych, generowanie schematów OpenAPI oraz integrację z DrizzleORM, zapewniając pełną spójność typów.

\subsection{DrizzleORM}

DrizzleORM pełni funkcję warstwy dostępu do danych. Zapewnia:

\begin{itemize}
    \item definiowanie schematów tabel zgodnych z TypeScript i Zod,
    \item API wzorowane na SQL, zapewniające niski narzut,
    \item bezpieczeństwo przed SQL injection,
    \item narzędzia do migracji bazy danych,
    \item interoperacyjność z PostgreSQL.
\end{itemize}

\subsection{Biblioteki dodatkowe}

Backend wykorzystuje również:

\begin{itemize}
    \item NodeMailer — wysyłanie wiadomości e-mail przez SMTP Google,
    \item Google Cloud Storage — przechowywanie zdjęć i generowanie podpisanych odnośników,
    \item Google Generative AI — komunikacja z modelem Gemini w celu przetwarzania zapytań języka naturalnego,
    \item node-cron — harmonogramowanie zadań cyklicznych,
    \item Winston — logowanie zdarzeń,
    \item bcrypt — bezpieczne hashowanie haseł użytkowników,
    \item dotenv — ładowanie zmiennych środowiskowych.
\end{itemize}

\section{Przechowywanie danych}

\subsection{PostgreSQL}

Głównym silnikiem bazy danych jest PostgreSQL. Wybrano go z uwagi na:

\begin{itemize}
    \item wysoką stabilność i niezawodność,
    \item zgodność z DrizzleORM,
    \item duży ekosystem narzędzi administracyjnych,
    \item dobrą wydajność w scenariuszach transakcyjnych.
\end{itemize}

Dane zapisywane są na dedykowanej partycji dyskowej, co ogranicza ryzyko problemów związanych z brakiem miejsca oraz zapewnia izolację operacji I/O.

\subsection{Kopie zapasowe}

Do wykonywania kopii zapasowych zastosowano:

\begin{itemize}
    \item borgbackup — deduplikacja i kompresja danych,
    \item borgmatic — automatyzacja harmonogramów, rotacja backupów, integracja z narzędziami administracyjnymi.
\end{itemize}

Zgodnie z założeniami projektu backupowane są wyłącznie dane z bazy, a kod aplikacji może zostać przywrócony z repozytorium.

\section{Moduł klasyfikatora}

Moduł klasyfikatora odpowiada za analizę zapytań języka naturalnego oraz przypisywanie ich do odpowiednich operacji API. Został wdrożony jako oddzielna mikro-usługa z uwagi na odmienny zestaw zależności.

Wykorzystuje:

\begin{itemize}
    \item sentence-transformers — generowanie osadzeń tekstowych,
    \item scikit-learn — podział danych oraz metody ewaluacyjne,
    \item numpy i torch — obliczenia tensorowe,
    \item FastAPI — udostępnienie punktów końcowych REST,
    \item Pydantic — walidacja danych wejściowych,
    \item uv — zarządzanie środowiskiem wykonawczym.
\end{itemize}

\section{Przepływ ruchu sieciowego}

Przepływ zapytań od użytkownika przebiega następująco:

\begin{enumerate}
    \item Użytkownik zapytuje DNS o domenę systemu, otrzymując adres serwerów Cloudflare, które pełnią funkcję WAF.
    \item Zapytanie trafia do infrastruktury Google Cloud Platform, gdzie jest filtrowane przez firewall.
    \item Ruch kierowany jest do instancji wirtualnej maszyny, w której Traefik pełni rolę reverse proxy.
    \item Traefik rozdziela ruch:
    \begin{itemize}
        \item ścieżka ``/'' — frontend (Nginx),
        \item ``/klasyfikator'' — moduł klasyfikatora,
        \item ``/api'' — backend aplikacji.
    \end{itemize}
\end{enumerate}

Backend po uwierzytelnieniu użytkownika za pomocą tokenów JWT realizuje żądania REST, mapując je na zapytania SQL przy użyciu DrizzleORM. W przypadku danych multimedialnych generowane są podpisane odnośniki do zasobów Cloud Storage. Dodatkowo backend komunikuje się z agentem Gemini LLM w celu analizy intencji użytkownika.

\section{Powtarzalność i izolacja środowiska uruchomieniowego (Docker)}

Komponenty aplikacji działają w izolowanych kontenerach Docker, co zapewnia powtarzalność środowiska oraz minimalizację zależności systemowych.

\textbf{TODO:} Opisać szczegółowo:
\begin{itemize}
    \item charakterystykę kontenerów i ich zalety,
    \item model warstw obrazu i wpływ na czas wdrażania,
    \item izolację zasobów oraz minimalne obrazy distroless,
    \item proces budowania obrazów w monorepo.
\end{itemize}

\section{Definicja infrastruktury jako kod (Terraform i Ansible)}

\textbf{TODO:} Rozszerzyć opis:
\begin{itemize}
    \item Terraform jako narzędzie Day~0 (provisioning VM, dysków, bucketów, firewalli),
    \item Ansible jako narzędzie Day~1--2 (konfiguracja systemu, Docker Engine, borgmatic),
    \item modułowość i powtarzalność procesów provisioningowych.
\end{itemize}

\section{Automatyzacja CI/CD}

Proces ciągłej integracji i wdrażania został oparty o GitHub Actions i Ansible.

\textbf{TODO:} Dopisać:
\begin{itemize}
    \item opis potoku kompilacji TypeScript,
    \item budowanie i publikację obrazów Docker,
    \item proces aktualizacji aplikacji na serwerze (pobranie obrazów, restart usług),
    \item model pracy z monorepo, pull requesty i kontrola jakości kodu.
\end{itemize}




